<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Pattern Tokenizer
        | Elasticsearch Reference [5.1]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch Reference [5.1]" /><link rel="up" href="analysis-tokenizers.html" title="Tokenizers" /><link rel="prev" href="analysis-keyword-tokenizer.html" title="Keyword Tokenizer" /><link rel="next" href="analysis-pathhierarchy-tokenizer.html" title="Path Hierarchy Tokenizer" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Docs/Elasticsearch/Reference/5.1" /></head><body><div xmlns="" class="page_header">You are looking at documentation for an older release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference
      [5.1]
    </a></span> » <span class="breadcrumb-link"><a href="analysis.html">Analysis</a></span> » <span class="breadcrumb-link"><a href="analysis-tokenizers.html">Tokenizers</a></span> » <span class="breadcrumb-node">Pattern Tokenizer</span></div><div xmlns="" class="navheader"><span class="prev"><a href="analysis-keyword-tokenizer.html">
              « 
              Keyword Tokenizer</a>
           
        </span><span class="next">
           
          <a href="analysis-pathhierarchy-tokenizer.html">Path Hierarchy Tokenizer
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="analysis-pattern-tokenizer"></a>Pattern Tokenizer<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/analysis/tokenizers/pattern-tokenizer.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>The <code class="literal">pattern</code> tokenizer uses a regular expression to either split text into
terms whenever it matches a word separator, or to capture matching text as
terms.</p><p>The default pattern is <code class="literal">\W+</code>, which splits text whenever it encounters
non-word characters.</p><div xmlns="" class="warning admon"><div class="icon"><img alt="Warning" src="images/icons/warning.png" /></div><div class="admon_content"><h3>Beware of Pathological Regular Expressions</h3><p xmlns="http://www.w3.org/1999/xhtml">The pattern tokenizer uses
<a class="ulink" href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_top">Java Regular Expressions</a>.</p><p xmlns="http://www.w3.org/1999/xhtml">A badly written regular expression could run very slowly or even throw a
StackOverflowError and cause the node it is running on to exit suddenly.</p><p xmlns="http://www.w3.org/1999/xhtml">Read more about <a class="ulink" href="http://www.regular-expressions.info/catastrophic.html" target="_top">pathological regular expressions and how to avoid them</a>.</p></div></div><h3><a id="_example_output_18"></a>Example output<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/analysis/tokenizers/pattern-tokenizer.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">POST _analyze
{
  "tokenizer": "pattern",
  "text": "The foo_bar_size's default is 5."
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>The above sentence would produce the following terms:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-text">[ The, foo_bar_size, s, default, is, 5 ]</pre></div><h3><a id="_configuration_19"></a>Configuration<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/analysis/tokenizers/pattern-tokenizer.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3><p>The <code class="literal">pattern</code> tokenizer accepts the following parameters:</p><div class="horizontal"><table cellpadding="4px" border="0"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td valign="top">
<p>
<code class="literal">pattern</code>
</p>
</td><td valign="top">
<p>
    A <a class="ulink" href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_top">Java regular expression</a>, defaults to <code class="literal">\W+</code>.
</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">flags</code>
</p>
</td><td valign="top">
<p>
    Java regular expression <a class="ulink" href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#field.summary" target="_top">flags</a>.
    lags should be pipe-separated, eg <code class="literal">"CASE_INSENSITIVE|COMMENTS"</code>.
</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">group</code>
</p>
</td><td valign="top">
<p>
    Which capture group to extract as tokens.  Defaults to <code class="literal">-1</code> (split).
</p>
</td></tr></tbody></table></div><h3><a id="_example_configuration_11"></a>Example configuration<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/analysis/tokenizers/pattern-tokenizer.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3><p>In this example, we configure the <code class="literal">pattern</code> tokenizer to break text into
tokens when it encounters commas:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">PUT my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_analyzer": {
          "tokenizer": "my_tokenizer"
        }
      },
      "tokenizer": {
        "my_tokenizer": {
          "type": "pattern",
          "pattern": ","
        }
      }
    }
  }
}

POST my_index/_analyze
{
  "analyzer": "my_analyzer",
  "text": "comma,separated,values"
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>The above example produces the following terms:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-text">[ comma, separated, values ]</pre></div><p>In the next example, we configure the <code class="literal">pattern</code> tokenizer to capture values
enclosed in double quotes (ignoring embedded escaped quotes <code class="literal">\"</code>).  The regex
itself looks like this:</p><pre class="literallayout">"((?:\\"|[^"]|\\")*)"</pre><p>And reads as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A literal <code class="literal">"</code>
</li><li class="listitem"><p class="simpara">
Start capturing:
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
A literal <code class="literal">\"</code> OR any character except <code class="literal">"</code>
</li><li class="listitem">
Repeat until no more characters match
</li></ul></div></li><li class="listitem">
A literal closing <code class="literal">"</code>
</li></ul></div><p>When the pattern is specified in JSON, the <code class="literal">"</code> and <code class="literal">\</code> characters need to be
escaped, so the pattern ends up looking like:</p><pre class="literallayout">\"((?:\\\\\"|[^\"]|\\\\\")+)\"</pre><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">PUT my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_analyzer": {
          "tokenizer": "my_tokenizer"
        }
      },
      "tokenizer": {
        "my_tokenizer": {
          "type": "pattern",
          "pattern": "\"((?:\\\\\"|[^\"]|\\\\\")+)\"",
          "group": 1
        }
      }
    }
  }
}

POST my_index/_analyze
{
  "analyzer": "my_analyzer",
  "text": "\"value\", \"value with embedded \\\" quote\""
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>The above example produces the following two terms:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-text">[ value, value with embedded \" quote ]</pre></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="analysis-keyword-tokenizer.html">
              « 
              Keyword Tokenizer</a>
           
        </span><span class="next">
           
          <a href="analysis-pathhierarchy-tokenizer.html">Path Hierarchy Tokenizer
               »
            </a></span></div></body></html>